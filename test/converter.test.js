const fs = require('fs');
const path = require('path');
const Converter = require('../src/Converter');

describe('Converter Integration Test', () => {
    const inputEpub = path.resolve(__dirname, 'fixtures/test.epub');
    const outputDir = path.resolve(__dirname, '../output_test');
    const outputMd = path.join(outputDir, 'test.md');

    // Ensure test.epub exists (it should have been generated by previous steps)
    if (!fs.existsSync(inputEpub)) {
        throw new Error('test.epub not found. Please generate it first.');
    }

    // Clean up output before test
    if (fs.existsSync(outputDir)) {
        fs.rmSync(outputDir, { recursive: true, force: true });
    }

    test('should convert EPUB to Markdown with correct structure', async () => {
        const converter = new Converter();
        await converter.convert(inputEpub, outputDir);

        expect(fs.existsSync(outputMd)).toBe(true);

        const content = fs.readFileSync(outputMd, 'utf-8');

        // 1. Check Frontmatter
        expect(content).toContain('title: "Complex Test Book"');
        expect(content).toContain('tags: [epub, book]');

        // 2. Check ATX Headers
        // Note: Obsidian style is "# Heading ^id" (or similar, Turndown might produce "# Heading ^id")
        // Turndown defaults: <h1 id="intro">Introduction</h1> -> # Introduction ^intro
        expect(content).toMatch(/#\s*Introduction\s*\^intro/);
        expect(content).toMatch(/#\s*Visuals & Links\s*\^chap2/);

        // 3. Check Anchor Injection (ID preservation)
        // Already verified above.

        // 4. Check Link Rewriting
        // Link to anchor in same file
        // Expect Target: ### Local Anchor Target ^local-anchor
        expect(content).toMatch(/###\s*Local Anchor Target\s*\^local-anchor/);
        // Expect Link: [[#^local-anchor|local anchor]]
        expect(content).toMatch(/\[\[#\^local-anchor\|local anchor\]\]/);

        // Link to another chapter's section
        // Expect Target: ## Section 2.1 ^chap2-section
        expect(content).toMatch(/##\s*Section 2\.1\s*\^chap2-section/);
        // Expect Link: [[#^chap2-section|Section 2.1]]
        expect(content).toMatch(/\[\[#\^chap2-section\|Section 2\.1\]\]/);

        // Footnote link
        // Expect: [^note1]
        expect(content).toMatch(/\[\^note1\]/);

        // Footnote definition
        // Expect: [^note1]: This is the footnote content.
        expect(content).toMatch(/\[\^note1\]: This is the footnote content\./);

        // EXTRA: Strict Obsidian Compliance Checks
        // 1. No HTML Anchors (<a id="...">)
        expect(content).not.toMatch(/<a\s+id=["'][^"']+["']\s*>/);
        expect(content).not.toMatch(/<a\s+name=["'][^"']+["']\s*>/);

        // 2. No Standard Markdown Internal Links ([text](#id))
        // We want ONLY [[#^id|text]]
        // This regex looks for [text](#id) pattern where id starts with #
        expect(content).not.toMatch(/\[.+?\]\(#.+?\)/);

        // 5. Check Image Extraction
        const assetsDir = path.join(outputDir, 'assets');
        expect(fs.existsSync(assetsDir)).toBe(true);
        const files = fs.readdirSync(assetsDir);
        // Expect cover and one image
        expect(files.some(f => f.endsWith('.jpg') || f.endsWith('.jpeg'))).toBe(true);

        // Check image markdown
        // ![A random placeholder image](assets/...)
        expect(content).toMatch(/!\[A random placeholder image\]\(assets\/.*\.jpe?g\)/);

        // 6. Check Complex Formatting
        // Lists (dash bullet)
        expect(content).toMatch(/- +Item 1/);
        expect(content).toMatch(/- +Item 2/);
        expect(content).toMatch(/- +Subitem A/);

        // Code Blocks (fenced)
        expect(content).toMatch(/```/);
        expect(content).toContain("console.log('Hello World');");

        // Text Styles
        expect(content).toMatch(/\*\*Bold\*\*/);
        expect(content).toMatch(/_Italic_/); // Turndown default is underscore for italic, but can be asterisk

        // Blockquotes
        expect(content).toMatch(/> This is a blockquote\./);

    }, 30000); // 30s timeout
});
