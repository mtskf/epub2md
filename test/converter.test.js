const fs = require('fs');
const path = require('path');
const Converter = require('../src/Converter');

describe('Converter Integration Test', () => {
    const inputEpub = path.resolve(__dirname, 'fixtures/test.epub');
    const outputDir = path.resolve(__dirname, '../output_test');
    const outputMd = path.join(outputDir, 'test.md');

    // Ensure test.epub exists (it should have been generated by previous steps)
    if (!fs.existsSync(inputEpub)) {
        throw new Error('test.epub not found. Please generate it first.');
    }

    // Clean up output before test
    if (fs.existsSync(outputDir)) {
        fs.rmSync(outputDir, { recursive: true, force: true });
    }

    test('should convert EPUB to Markdown with correct structure', async () => {
        const converter = new Converter();
        await converter.convert(inputEpub, outputDir);

        expect(fs.existsSync(outputMd)).toBe(true);

        const content = fs.readFileSync(outputMd, 'utf-8');

        // 1. Check Frontmatter
        expect(content).toContain('title: "Complex Test Book"');
        expect(content).toContain('cover: "assets/cover.jpeg"');
        expect(content).toContain('read: false');
        expect(content).toContain('rating: ');
        expect(content).toContain('tags: [converted-from-epub, book]');

        // 1a. TOC + chapter-level anchors stay linked
        expect(content).toContain('[[#Introduction|Introduction]]');
        expect(content).toContain('[[#Visuals|Visuals]]');
        expect(content).toContain('[[#Formatting|Formatting]]');
        expect(content).toMatch(/#\s*Table Of Contents/);

        // 2. Check ATX Headers
        // Note: Heading IDs no longer surface as block IDs; we link via heading text.
        expect(content).toMatch(/#\s*Introduction/);
        expect(content).toMatch(/#\s*Visuals & Links/);

        // 3. Check Anchor Injection (ID preservation)
        // Already verified above.

        // 4. Check Link Rewriting
        // Link to anchor in same file
        // Expect Target: ### Local Anchor Target ^local-anchor
        expect(content).toMatch(/###\s*Local Anchor Target/);
        // Expect Link: [[#Local Anchor Target|local anchor]]
        expect(content).toMatch(/\[\[#Local Anchor Target\|local anchor\]\]/);

        // Link to another chapter's section
        // Expect Target: ## Section 2.1 ^chap2-section
        expect(content).toMatch(/##\s*Section 2\.1/);
        // Expect Link: [[#Section 2.1|Section 2.1]]
        expect(content).toMatch(/\[\[#Section 2\.1\|Section 2\.1\]\]/);

        // Footnote link
        // Expect: [^note1]
        expect(content).toMatch(/\[\^note1\]/);

        // Footnote definition
        // Expect: [^note1]: This is the footnote content.
        expect(content).toMatch(/\[\^note1\]: This is the footnote content\./);

        // EXTRA: Strict Obsidian Compliance Checks
        // 1. No HTML Anchors (<a id="...">)
        expect(content).not.toMatch(/<a\s+id=["'][^"']+["']\s*>/);
        expect(content).not.toMatch(/<a\s+name=["'][^"']+["']\s*>/);

        // 2. No Standard Markdown Internal Links ([text](#id))
        // We want ONLY [[#^id|text]]
        // This regex looks for [text](#id) pattern where id starts with #
        expect(content).not.toMatch(/\[.+?\]\(#.+?\)/);

        // 5. Check Image Extraction
        const assetsDir = path.join(outputDir, 'assets');
        expect(fs.existsSync(assetsDir)).toBe(true);
        const files = fs.readdirSync(assetsDir);
        // Expect cover and one image
        expect(files.some((f) => f.endsWith('.jpg') || f.endsWith('.jpeg'))).toBe(true);

        // Check image markdown
        // ![A random placeholder image](assets/...)
        expect(content).toMatch(/!\[A random placeholder image\]\(assets\/.*\.jpe?g\)/);

        // 6. Check Complex Formatting
        // Lists (dash bullet)
        expect(content).toMatch(/- +Item 1/);
        expect(content).toMatch(/- +Item 2/);
        expect(content).toMatch(/- +Subitem A/);

        // Code Blocks (fenced)
        expect(content).toMatch(/```/);
        expect(content).toContain("console.log('Hello World');");

        // Text Styles
        expect(content).toMatch(/\*\*Bold\*\*/);
        expect(content).toMatch(/_Italic_/); // Turndown default is underscore for italic, but can be asterisk

        // Blockquotes
        expect(content).toMatch(/> This is a blockquote\./);
    }, 30000); // 30s timeout
});

describe('Anchor preprocessing', () => {
    test('hoists standalone anchors onto the next heading', () => {
        const converter = new Converter();
        converter.configureTurndown();

        const html = '<a id="foreword"></a><h1>Foreword</h1>';
        const preprocessed = converter._preprocessAnchors(html);
        const md = converter.turndownService.turndown(preprocessed);

        expect(md.trim()).toBe('# Foreword');
    });

    test('converts chapter title paragraphs to headings and attaches anchor', () => {
        const converter = new Converter();
        converter.configureTurndown();

        const html = '<a id="c1"></a><p class="chaptitle">Chapter Title</p>';
        const preprocessed = converter._preprocessAnchors(html);
        const md = converter.turndownService.turndown(preprocessed);

        expect(md.trim()).toBe('# Chapter Title');
    });
});
